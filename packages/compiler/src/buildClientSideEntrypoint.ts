import type { Project } from 'ts-morph'

import {
  FallbackSourceFileModule,
  LayoutSourceFileModule,
  RedirectSourceFileModule,
  SourceFileModule,
} from './SourceFileModule.js'

export function buildClientSideEntrypoint(sourceFileModules: SourceFileModule[], project: Project) {
  const [imports, modules, fallback] = buildImportsAndModules(sourceFileModules)
  const entrypoint = project.createSourceFile(
    'bootstrap.ts',
    `/* This file was auto-generated by @typed/compiler */

import * as F from '@fp-ts/data/Function'
import * as Fx from '@typed/fx/index.js'
import { Module, buildModules, provideBrowserIntrinsics } from '@typed/framework/index.js'
import { renderInto } from '@typed/html/index.js'
${imports.join('\n')}

const parentElementId = 'application'
const parentElement = document.getElementById(parentElementId)

if (!parentElement) {
  throw new Error(\`Could not find element with id \${parentElementId}"\`)
}

const matcher = buildModules([${modules.join(',')}])
const main = ${fallback ? runMatcherWithFallback(fallback) : `matcher.run()`}

const program = F.pipe(
  main,
  renderInto(parentElement),
  provideBrowserIntrinsics(window, { parentElement }),
)

document.addEventListener('DOMContentLoaded', () => Fx.unsafeRunAsync(program))
`,
  )

  const diagnostics = entrypoint.getPreEmitDiagnostics()

  if (diagnostics.length > 0) {
    throw new Error(project.formatDiagnosticsWithColorAndContext(diagnostics))
  }

  return entrypoint
}

function buildImportsAndModules(sourceFileModules: SourceFileModule[]) {
  let _id = 0
  const imports: string[] = []
  const modules: string[] = []
  const filePathToId = new Map<string, number>()

  let layout: [LayoutSourceFileModule, string] | undefined
  let fallback: [FallbackSourceFileModule | RedirectSourceFileModule, string] | undefined

  for (const mod of sourceFileModules) {
    const id = _id++
    const filePath = mod.sourceFile.getFilePath()

    filePathToId.set(filePath, id)

    const moduleName = `typedModule${id}`

    imports.push(`import * as ${moduleName} from '${filePath.replace(/.ts(x)?/, '.js$1')}'`)

    switch (mod._tag) {
      case 'Redirect/Basic':
      case 'Redirect/Environment':
      case 'Fallback/Basic':
      case 'Fallback/Environment': {
        if (!fallback) {
          fallback = [mod, moduleName]
        } else {
          throw new Error('Only one root-level fallback module is allowed')
        }

        continue
      }
      case 'Layout/Basic':
      case 'Layout/Environment': {
        layout = [mod, moduleName]

        continue
      }

      case 'Render/Basic': {
        modules.push(
          `Module.make(${moduleName}.route, ${
            mod.isFx ? `() => ${moduleName}.main,` : `${moduleName}.main,`
          }${
            mod.hasLayout
              ? `{ layout: ${moduleName}.layout }`
              : layout
              ? ` { layout: ${layout[1]}.layout }`
              : ''
          })`,
        )
        continue
      }
      case 'Render/Environment': {
        modules.push(
          `Module.make(${moduleName}.route, F.flow(${
            mod.isFx ? `() => ${moduleName}.main,` : `${moduleName}.main,`
          }, Fx.provideSomeLayer(${moduleName}.environment)), ${
            layout ? ` { layout: ${layout[1]}.layout }` : ''
          })`,
        )
        continue
      }
    }
  }

  return [imports, modules, fallback] as const
}

function runMatcherWithFallback([fallback, fallbackModuleName]: [
  FallbackSourceFileModule | RedirectSourceFileModule,
  string,
]) {
  switch (fallback._tag) {
    case 'Redirect/Basic':
      return `matcher.redirectTo(${fallbackModuleName}.route, ${fallbackModuleName}?.params ?? {})`
    case 'Redirect/Environment': {
      return `matcher.redirectTo(${fallbackModuleName}.route.provideLayer(${fallbackModuleName}.environment), ${fallbackModuleName}?.params ?? {})`
    }
    case 'Fallback/Basic':
      return `matcher.notFound(${
        fallback.isFx ? `() => ${fallbackModuleName}.fallback` : `${fallbackModuleName}.fallback`
      })`
    case 'Fallback/Environment': {
      return `matcher.notFound(${
        fallback.isFx
          ? `() => F.pipe(${fallbackModuleName}.fallback, Fx.provideSomeLayer(${fallbackModuleName}.environment))`
          : `F.flow(${fallbackModuleName}.fallback, Fx.provideSomeLayer(${fallbackModuleName}.environment))`
      })`
    }
  }
}
