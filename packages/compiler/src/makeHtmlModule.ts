import { readFileSync } from 'fs'
import { basename, dirname, join, relative, resolve } from 'path'

import { Project, SourceFile } from 'ts-morph'

import { addNamedImport, appendText } from './ts-morph-helpers.js'

export function makeHtmlModule(
  project: Project,
  fileName: string,
  importer: string,
  serverOutputDirectory: string,
  clientOutputDirectory: string,
): SourceFile {
  const htmlFilePath = resolve(dirname(importer), fileName)
  const sourceFile = project.createSourceFile(
    importer + `?html=${htmlFilePath}`,
    `/* File auto-generated by @typed/compiler */`,
    { overwrite: true },
  )

  const html = readFileSync(htmlFilePath, 'utf-8').toString()
  const docType = `<!DOCTYPE ${parseDocType(html)}>`
  const htmlAttributes = parseHtmlAttributes(html)

  let relativeClientOutput = relative(serverOutputDirectory, clientOutputDirectory)

  if (!relativeClientOutput.startsWith('.')) {
    relativeClientOutput = `./${relativeClientOutput}`
  }

  addNamedImport(sourceFile, ['IncomingMessage'], 'http')
  addNamedImport(sourceFile, ['readFileSync'], 'fs')
  addNamedImport(sourceFile, ['fileURLToPath'], 'url')
  addNamedImport(sourceFile, ['ServerWindowOptions'], '@typed/framework')
  addNamedImport(sourceFile, ['makeServerWindow'], '@typed/framework/makeServerWindow')

  appendText(
    sourceFile,
    `export const assetDirectory: string = '${relativeClientOutput}'`,
  )
  appendText(
    sourceFile,
    `export const htmlAttributes: Record<string, string> = ${JSON.stringify(htmlAttributes)}`,
  )
  appendText(sourceFile, `export const docType: string = '${docType}'`)

  const relativeFilePath = join(relativeClientOutput, basename(htmlFilePath))

  appendText(
    sourceFile,
    `export const html = import.meta.env.PROD ? readFileSync(fileURLToPath(new URL('${relativeFilePath}', import.meta.url))).toString().trim() : \`${html.trim()}\``,
  )

  appendText(
    sourceFile,
    `export function makeWindow(req: IncomingMessage, options?: ServerWindowOptions) {
  const win = makeServerWindow(req, options)
  const documentElement = win.document.documentElement

  documentElement.innerHTML = html

  for (const [key, value] of Object.entries(htmlAttributes)) {
    documentElement.setAttribute(key, value)
  }

  return win
}`,
  )

  return sourceFile
}

function parseDocType(html: string) {
  const docTypeRegex = /<!DOCTYPE\s+(.+)>/i

  const docTypeMatch = html.match(docTypeRegex)

  return docTypeMatch ? docTypeMatch[1] : 'html'
}

function parseHtmlAttributes(html: string): Record<string, string> {
  const htmlAttributesRegex = /<html\s+([^>]+)>/i
  const htmlAttributesMatch = html.match(htmlAttributesRegex)

  if (!htmlAttributesMatch) return {}

  return Object.fromEntries(
    htmlAttributesMatch[1].split(/\s/g).map((kv) => {
      const [k, v = ''] = kv.split('=')

      return [k, v.replace(/"|'/g, '')]
    }),
  )
}
