import { dirname, relative } from 'path'

import { Project, SourceFile } from 'ts-morph'
import { ViteDevServer } from 'vite'

import { cleanHtml } from './cleanHtml.js'
import { addNamedImport, appendText } from './ts-morph-helpers.js'

export interface HtmlModuleOptions {
  readonly project: Project
  readonly filePath: string
  readonly html: string
  readonly importer: string
  readonly serverOutputDirectory: string
  readonly clientOutputDirectory: string
  readonly devServer?: ViteDevServer
}

export async function makeHtmlModule(options: HtmlModuleOptions): Promise<SourceFile> {
  const {
    project,
    filePath,
    html,
    importer,
    serverOutputDirectory,
    clientOutputDirectory,
    devServer,
  } = options
  const sourceFile = project.createSourceFile(
    importer + `?html=${filePath}`,
    `/* File auto-generated by @typed/compiler */`,
    { overwrite: true },
  )

  const docType = `<!DOCTYPE ${parseDocType(html)}>`
  const htmlAttributes = parseHtmlAttributes(html)

  addNamedImport(sourceFile, ['IncomingMessage'], 'http')
  addNamedImport(sourceFile, ['readFileSync'], 'fs')
  addNamedImport(sourceFile, ['fileURLToPath'], 'url')
  addNamedImport(
    sourceFile,
    ['makeServerWindow', 'ServerWindowOptions'],
    '@typed/framework/makeServerWindow',
  )

  appendText(
    sourceFile,
    `export const assetDirectory: string = '${
      devServer ? dirname(importer) : getRelativePath(serverOutputDirectory, clientOutputDirectory)
    }'`,
  )
  appendText(
    sourceFile,
    `export const htmlAttributes: Record<string, string> = ${JSON.stringify(htmlAttributes)}`,
  )
  appendText(sourceFile, `export const docType: string = \`${docType.trim()}\``)

  appendText(sourceFile, await generateHtmlExport(filePath, html, docType, devServer))

  appendText(
    sourceFile,
    `export function makeWindow(req: IncomingMessage, options?: ServerWindowOptions) {
  const win = makeServerWindow(req, options)
  const documentElement = win.document.documentElement

  documentElement.innerHTML = html

  for (const [key, value] of Object.entries(htmlAttributes)) {
    documentElement.setAttribute(key, value)
  }

  return win
}`,
  )

  return sourceFile
}

function parseDocType(html: string) {
  const docTypeRegex = /<!DOCTYPE\s+(.+)>/i

  const docTypeMatch = html.match(docTypeRegex)

  return docTypeMatch ? docTypeMatch[1] : 'html'
}

function parseHtmlAttributes(html: string): Record<string, string> {
  const htmlAttributesRegex = /<html\s+([^>]+)>/i
  const htmlAttributesMatch = html.match(htmlAttributesRegex)

  if (!htmlAttributesMatch) return {}

  return Object.fromEntries(
    htmlAttributesMatch[1].split(/\s/g).map((kv) => {
      const [k, v = ''] = kv.split('=')

      return [k, v.replace(/"|'/g, '')]
    }),
  )
}

async function generateHtmlExport(
  filePath: string,
  html: string,
  docType: string,
  devServer?: ViteDevServer,
) {
  if (devServer) {
    html = await devServer.transformIndexHtml(filePath, html)
  }

  html = cleanHtml(html, docType)

  return `export const html: string = \`${html}\``
}

function getRelativePath(serverOutputDirectory: string, clientOutputDirectory: string) {
  let relativeClientOutput = relative(serverOutputDirectory, clientOutputDirectory)

  if (!relativeClientOutput.startsWith('.')) {
    relativeClientOutput = `./${relativeClientOutput}`
  }

  return relativeClientOutput
}
