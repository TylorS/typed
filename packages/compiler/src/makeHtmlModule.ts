import { EOL } from 'os'
import { dirname, relative } from 'path'

import { minify } from 'html-minifier'
import type { Project, SourceFile } from 'ts-morph'
import type { ViteDevServer } from 'vite'

import { cleanHtml } from './cleanHtml.js'
import { addNamedImport, appendText } from './ts-morph-helpers.js'

export interface HtmlModuleOptions {
  readonly project: Project
  readonly filePath: string
  readonly html: string
  readonly importer: string
  readonly serverOutputDirectory: string
  readonly clientOutputDirectory: string
  readonly devServer?: ViteDevServer
}

export async function makeHtmlModule(options: HtmlModuleOptions): Promise<SourceFile> {
  const {
    project,
    filePath,
    html,
    importer,
    serverOutputDirectory,
    clientOutputDirectory,
    devServer,
  } = options
  const tsPath = `${filePath}.__generated__.ts`
  const sourceFile = project.createSourceFile(
    tsPath,
    `/* File auto-generated by @typed/compiler */`,
    { overwrite: true },
  )

  const docType = `<!DOCTYPE ${parseDocType(html)}>`
  const htmlAttributes = parseHtmlAttributes(html)

  addNamedImport(sourceFile, ['IncomingMessage'], 'http', true)
  addNamedImport(
    sourceFile,
    ['makeServerWindow', 'type ServerWindowOptions'],
    '@typed/framework/makeServerWindow',
  )

  appendText(
    sourceFile,
    EOL +
      `export const assetDirectory: string = '${
        devServer
          ? dirname(importer)
          : getRelativePath(serverOutputDirectory, clientOutputDirectory)
      }'`,
  )
  appendText(
    sourceFile,
    EOL + `export const htmlAttributes: Record<string, string> = ${JSON.stringify(htmlAttributes)}`,
  )
  appendText(sourceFile, EOL + `export const docType: string = \`${docType.trim()}\``)

  appendText(sourceFile, EOL + (await generateHtmlExport(filePath, html, docType, devServer)))

  appendText(
    sourceFile,
    EOL +
      `export function makeWindow(req: IncomingMessage, options?: ServerWindowOptions): ReturnType<typeof makeServerWindow> {
  const win = makeServerWindow(req, options)
  const documentElement = win.document.documentElement

  documentElement.innerHTML = html

  for (const [key, value] of Object.entries(htmlAttributes)) {
    documentElement.setAttribute(key, value)
  }

  return win
}`,
  )

  return sourceFile
}

function parseDocType(html: string) {
  const docTypeRegex = /<!DOCTYPE\s+(.+)>/i

  const docTypeMatch = html.match(docTypeRegex)

  return docTypeMatch ? docTypeMatch[1] : 'html'
}

function parseHtmlAttributes(html: string): Record<string, string> {
  const htmlAttributesRegex = /<html\s+([^>]+)>/i
  const htmlAttributesMatch = html.match(htmlAttributesRegex)

  if (!htmlAttributesMatch) return {}

  return Object.fromEntries(
    htmlAttributesMatch[1].split(/\s/g).map((kv) => {
      const [k, v = ''] = kv.split('=')

      return [k, v.replace(/"|'/g, '')]
    }),
  )
}

async function generateHtmlExport(
  filePath: string,
  html: string,
  docType: string,
  devServer?: ViteDevServer,
) {
  if (devServer) {
    html = await devServer.transformIndexHtml(filePath, html)
  } else {
    html = minify(html, { sortAttributes: true, sortClassName: true })
  }

  html = cleanHtml(html, docType)

  return `export const html: string = \`${html}\``
}

function getRelativePath(serverOutputDirectory: string, clientOutputDirectory: string) {
  let relativeClientOutput = relative(serverOutputDirectory, clientOutputDirectory)

  if (!relativeClientOutput.startsWith('.')) {
    relativeClientOutput = `./${relativeClientOutput}`
  }

  return relativeClientOutput
}
