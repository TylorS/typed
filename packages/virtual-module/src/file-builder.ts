/**
 * A pretty minimal helper for building up a file's content through text strings.
 */
export class FileBuilder {
  protected imports = new Map<string, ImportStatement>()
  protected statements: Statement[] = []

  protected addImport(importStatement: ImportStatement): this {
    const current = this.imports.get(importStatement.moduleSpecifier)

    if (current) {
      if (current._tag !== importStatement._tag) {
        throw new Error(
          `Cannot add import ${importStatement.moduleSpecifier} with different type of import statement. Generated file content will be incorrect.`,
        )
      }

      // Merge named imports
      if (current._tag === 'ImportDeclaration') {
        for (const namedImport of (importStatement as ImportDeclarationStatement).namedImports) {
          const existing = current.namedImports.find((x) => x.name === namedImport.name)

          if (existing && existing.alias !== namedImport.alias) {
            throw new Error(
              `Cannot add import ${importStatement.moduleSpecifier} with different aliases. Generated file content will be incorrect.`,
            )
          }

          if (!existing) {
            current.namedImports.push(namedImport)
          }
        }
      }
    } else {
      this.imports.set(importStatement.moduleSpecifier, importStatement)
    }

    return this
  }

  public addImportDeclaration(namedImports: NamedImport[], moduleSpecifier: string): this {
    return this.addImport(ImportDeclarationStatement(namedImports, moduleSpecifier))
  }

  public addNamespaceImportDeclaration(namespace: string, moduleSpecifier: string): this {
    return this.addImport(NamespaceImportDeclarationStatement(namespace, moduleSpecifier))
  }

  public addStatement(statement: Statement): this {
    this.statements.push(statement)
    return this
  }

  public addText(text: string): this {
    return this.addStatement(TextStatement(text))
  }

  public addVariableDeclaration(
    type: 'const' | 'let' | 'var',
    name: string,
    initializer?: string,
    typeAnnotation?: string,
  ): this {
    return this.addStatement(VariableDeclaration(type, name, initializer, typeAnnotation))
  }

  public addFunctionDeclaration(
    name: string,
    exported: boolean,
    typeParameters: readonly TypeParameter[] = [],
    parameters: readonly FunctionParameter[] = [],
    body: readonly Statement[] = [],
    returnType?: string,
  ) {
    return this.addStatement(
      FunctionDeclaration(name, exported, typeParameters, parameters, body, returnType),
    )
  }

  public addInterfaceDeclaration(
    name: string,
    exported: boolean,
    typeParameters: readonly TypeParameter[] = [],
    members: readonly InterfaceMember[] = [],
    extensions: readonly InterfaceExtension[] = [],
  ) {
    return this.addStatement(
      InterfaceDeclaration(name, exported, typeParameters, members, extensions),
    )
  }

  public build(header: string = 'File auto-generated by @typed/virtual-module'): string {
    let result = `/* ${header} */`

    for (const importStatement of this.imports.values()) {
      result += this.printImportStatement(importStatement)
    }

    for (const statement of this.statements) {
      result += this.printStatement(statement)
    }

    return result
  }

  protected printImportStatement(importStatement: ImportStatement): string {
    switch (importStatement._tag) {
      case 'ImportDeclaration':
        return `import { ${this.printNamedImports(importStatement.namedImports)} } from '${
          importStatement.moduleSpecifier
        }'`
      case 'NamespaceImportDeclaration':
        return `import * as ${importStatement.namespace} from '${importStatement.moduleSpecifier}'`
    }
  }

  protected printNamedImports(namedImports: NamedImport[]): string {
    return namedImports
      .map((namedImport) => {
        if (namedImport.alias) {
          return `${namedImport.name} as ${namedImport.alias}`
        }

        return namedImport.name
      })
      .join(', ')
  }

  protected printStatement(statement: Statement): string {
    switch (statement._tag) {
      case 'TextStatement':
        return statement.text
      case 'VariableDeclaration':
        return this.printVariableDeclaration(statement)
      case 'FunctionDeclaration':
        return this.printFunctionDeclaration(statement)
      case 'InterfaceDeclaration':
        return this.printInterfaceDeclaration(statement)
    }
  }

  protected printVariableDeclaration(variableDeclaration: VariableDeclaration): string {
    return `${variableDeclaration.varType} ${variableDeclaration.name}${
      variableDeclaration.initializer ? ` = ${variableDeclaration.initializer}` : ''
    }`
  }

  protected printFunctionDeclaration(functionDeclaration: FunctionDeclaration): string {
    let text = ''

    if (functionDeclaration.exported) {
      text += `export `
    }

    text += `function ${functionDeclaration.name}`

    if (functionDeclaration.typeParameters.length > 0) {
      text += `<${this.printTypeParameters(functionDeclaration.typeParameters)}>`
    }

    text += `(${this.printFunctionParameters(functionDeclaration.parameters)})`

    if (functionDeclaration.returnType) {
      text += `: ${functionDeclaration.returnType}`
    }

    text += ` {\n${this.printFunctionBody(functionDeclaration.body)}\n}`

    return text
  }

  protected printTypeParameters(typeParameters: readonly TypeParameter[]): string {
    return typeParameters
      .map((typeParameter) => {
        if (typeParameter.constraint) {
          return `${typeParameter.name} extends ${typeParameter.constraint}`
        }

        return typeParameter.name
      })
      .join(', ')
  }

  protected printFunctionParameters(functionParameters: readonly FunctionParameter[]): string {
    return functionParameters
      .map((functionParameter) => {
        if (functionParameter.type) {
          return `${functionParameter.name}: ${functionParameter.type}`
        }

        return functionParameter.name
      })
      .join(', ')
  }

  protected printFunctionBody(functionBody: FunctionDeclarationBody): string {
    return functionBody
      .map((statement) => {
        if (statement._tag === 'ReturnExpression') {
          return `return ${statement.expression}`
        }

        return this.printStatement(statement)
      })
      .join('\n')
  }

  protected printInterfaceDeclaration(interfaceDeclaration: InterfaceDeclaration): string {
    let text = ''

    if (interfaceDeclaration.exported) {
      text += `export `
    }

    text += `interface ${interfaceDeclaration.name}`

    if (interfaceDeclaration.typeParameters.length > 0) {
      text += `<${this.printTypeParameters(interfaceDeclaration.typeParameters)}>`
    }

    if (interfaceDeclaration.extensions.length > 0) {
      text += ` extends ${this.printInterfaceExtensions(interfaceDeclaration.extensions)}`
    }

    text += ` {\n${this.printInterfaceMembers(interfaceDeclaration.members)}\n}`

    return text
  }

  protected printInterfaceMembers(interfaceMembers: readonly InterfaceMember[]): string {
    return interfaceMembers
      .map((interfaceMember) => {
        if (interfaceMember.type) {
          return `${interfaceMember.name}: ${interfaceMember.type}`
        }

        return interfaceMember.name
      })
      .join('\n')
  }

  protected printInterfaceExtensions(interfaceExtensions: readonly InterfaceExtension[]): string {
    return interfaceExtensions
      .map((interfaceExtension) => {
        if (interfaceExtension.typeParameters.length > 0) {
          return `${interfaceExtension.name}<${this.printTypeParameters(
            interfaceExtension.typeParameters,
          )}>`
        }

        return interfaceExtension.name
      })
      .join(', ')
  }
}

// Note: Default exports are not currently supported, they're bad design anyway.
export type ImportStatement = ImportDeclarationStatement | NamespaceImportDeclarationStatement

export interface ImportDeclarationStatement {
  readonly _tag: 'ImportDeclaration'
  readonly namedImports: NamedImport[]
  readonly moduleSpecifier: string
}

export function ImportDeclarationStatement(
  namedImports: NamedImport[],
  moduleSpecifier: string,
): ImportDeclarationStatement {
  return {
    _tag: 'ImportDeclaration',
    namedImports,
    moduleSpecifier,
  }
}

export interface NamedImport {
  readonly name: string
  readonly alias?: string
}

export function NamedImport(name: string, alias?: string): NamedImport {
  return {
    name,
    alias,
  }
}

export interface NamespaceImportDeclarationStatement {
  readonly _tag: 'NamespaceImportDeclaration'
  readonly namespace: string
  readonly moduleSpecifier: string
}

export function NamespaceImportDeclarationStatement(
  namespace: string,
  moduleSpecifier: string,
): NamespaceImportDeclarationStatement {
  return {
    _tag: 'NamespaceImportDeclaration',
    namespace,
    moduleSpecifier,
  }
}

export type Statement =
  | TextStatement
  | VariableDeclaration
  | FunctionDeclaration
  | InterfaceDeclaration

export interface TextStatement {
  readonly _tag: 'TextStatement'
  readonly text: string
}

export function TextStatement(text: string): TextStatement {
  return {
    _tag: 'TextStatement',
    text,
  }
}

export interface VariableDeclaration {
  readonly _tag: 'VariableDeclaration'
  readonly varType: 'const' | 'let' | 'var'
  readonly name: string
  readonly initializer?: string
  readonly type?: string
}

export function VariableDeclaration(
  varType: 'const' | 'let' | 'var',
  name: string,
  initializer?: string,
  type?: string,
): VariableDeclaration {
  return {
    _tag: 'VariableDeclaration',
    varType,
    name,
    initializer,
    type,
  }
}

export interface FunctionDeclaration {
  readonly _tag: 'FunctionDeclaration'
  readonly name: string
  readonly exported: boolean
  readonly typeParameters: readonly TypeParameter[]
  readonly parameters: readonly FunctionParameter[]
  readonly body: FunctionDeclarationBody
  readonly returnType?: string
}

export type FunctionDeclarationBody = ReadonlyArray<Statement | ReturnExpression>

export interface TypeParameter {
  readonly name: string
  readonly constraint?: string
}

export interface FunctionParameter {
  readonly name: string
  readonly type?: string
}

export function FunctionDeclaration(
  name: string,
  exported: boolean,
  typeParameters: readonly TypeParameter[],
  parameters: readonly FunctionParameter[],
  body: FunctionDeclarationBody,
  returnType?: string,
): FunctionDeclaration {
  return {
    _tag: 'FunctionDeclaration',
    name,
    exported,
    typeParameters,
    parameters,
    body,
    returnType,
  }
}

export function TypeParameter(name: string, constraint?: string): TypeParameter {
  return {
    name,
    constraint,
  }
}

export function FunctionParameter(name: string, type?: string): FunctionParameter {
  return {
    name,
    type,
  }
}

export interface InterfaceDeclaration {
  readonly _tag: 'InterfaceDeclaration'
  readonly name: string
  readonly exported: boolean
  readonly typeParameters: readonly TypeParameter[]
  readonly members: readonly InterfaceMember[]
  readonly extensions: readonly InterfaceExtension[]
}

export function InterfaceDeclaration(
  name: string,
  exported: boolean,
  typeParameters: readonly TypeParameter[] = [],
  members: readonly InterfaceMember[] = [],
  extensions: readonly InterfaceExtension[] = [],
): InterfaceDeclaration {
  return {
    _tag: 'InterfaceDeclaration',
    name,
    exported,
    typeParameters,
    members,
    extensions,
  }
}

export interface InterfaceMember {
  readonly _tag: 'InterfaceMember'
  readonly name: string
  readonly type?: string
}

export function InterfaceMember(name: string, type?: string): InterfaceMember {
  return {
    _tag: 'InterfaceMember',
    name,
    type,
  }
}

export interface InterfaceExtension {
  readonly _tag: 'InterfaceExtension'
  readonly name: string
  readonly typeParameters: readonly TypeParameter[]
}

export function InterfaceExtension(
  name: string,
  typeParameters: readonly TypeParameter[] = [],
): InterfaceExtension {
  return {
    _tag: 'InterfaceExtension',
    name,
    typeParameters,
  }
}

export interface ReturnExpression {
  readonly _tag: 'ReturnExpression'
  readonly expression: string
}

export function ReturnExpression(expression: string): ReturnExpression {
  return {
    _tag: 'ReturnExpression',
    expression,
  }
}
