import { promises, readFileSync } from 'fs'
import { dirname, join, relative, resolve } from 'path'

import { ModuleKind, Extension } from 'typescript'

import { VirtualModuleFile, VirtualModuleFilePlugin, ProductionParams } from './VirtualModulePlugin'
import { FileBuilder } from './file-builder'

const htmlPlugin: VirtualModuleFilePlugin<null> = {
  name: '@typed/virtual-module/html',
  regex: /^html:(.+)$/,
  resolveVirtualModule: (id, importer) =>
    VirtualModuleFile({
      id,
      importer,
      fileName: createFileName(id, importer),
      kind: ModuleKind.ES2020,
      extension: Extension.Ts,
    }),
  generateMetadata: () => null,
  generateTypeScriptContent: (vm, { params }) => {
    const placeholder = getPlaceholderParam(params)
    const content = readFileSync(getHtmlFileName(vm)).toString()

    return buildFileContent(dirname(vm.fileName), content, placeholder)
  },
  generateProductionContent: async (vm, { params }, prodParams) => {
    let content: string
    let assetDirectory: string

    // TransformHtml signals we're in dev mode with vite, so we just read the source file and transform
    if (prodParams.transformHtml) {
      content = await prodParams.transformHtml(readFileSync(getHtmlFileName(vm)).toString())
      assetDirectory = dirname(vm.importer)
    } else {
      // Otherwise, we fully expect the transformed file to be in the client output directory
      content = await getProductionContent(vm, prodParams.clientOutputDirectory)
      assetDirectory = relative(prodParams.serverOutputDirectory, prodParams.clientOutputDirectory)

      if (!assetDirectory.startsWith('.')) {
        assetDirectory = `./${assetDirectory}`
      }
    }

    const placeholder = getPlaceholderParam(params)

    return buildFileContent(assetDirectory, content, placeholder, prodParams)
  },
}

export = htmlPlugin

function getHtmlFileName(vm: VirtualModuleFile) {
  return resolve(dirname(vm.importer), vm.id.replace('html:', '') + '.html')
}

function createFileName(id: string, importer: string) {
  return resolve(dirname(importer), id.replace('html:', '') + '.html.__generated__.ts')
}

function getPlaceholderParam(params: Record<string, any>): RegExp {
  if (params.placeholder && typeof params.placeholder === 'string') {
    return new RegExp(params.placeholder)
  }

  return /<!--\s+?TYPED_CONTENT\s+?-->/
}

function parseBasePath(html: string, existingBase?: string): string | null {
  const match = html.match(/<base\s+href="(.+)"\s*\/?>/)

  if (!match) {
    return null
  }

  return existingBase ? join(existingBase, match[1]) : match[1]
}

function formatStringLiteralOrNull(value: string | null) {
  if (value === null) {
    return 'null'
  }

  return `'${value}'`
}

async function getProductionContent(vm: VirtualModuleFile, clientOutputDirectory: string) {
  const sourceFileName = getHtmlFileName(vm)
  const relativeFileName = relative(clientOutputDirectory, sourceFileName)
  const outputFileName = join(clientOutputDirectory, relativeFileName)
  const content = await promises.readFile(outputFileName).then((buffer) => buffer.toString())

  return content
}

function buildFileContent(
  assetDirectory: string,
  content: string,
  placeholder: RegExp,
  prodParams?: ProductionParams,
) {
  const [before, after] = content.split(placeholder).filter((x) => x !== '')
  const basePath = parseBasePath(content, prodParams?.base)

  return new FileBuilder()
    .addText(`export const content: string = \`${content}\`;`)
    .addText(`export const placeholder: RegExp = /${placeholder.source}/${placeholder.flags};`)
    .addText(`export const before: string = \`${before}\`;`)
    .addText(`export const after: string = \`${after}\`;`)
    .addText(`export const basePath: string | null = ${formatStringLiteralOrNull(basePath)};`)
    .addText(`export const assetDirectory: string = '${assetDirectory}';`)
    .build(`File auto-generated by @typed/virtual-module/html`)
}
